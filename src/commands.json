{
  "plan-feature": {
    "description": "Creates a detailed step-by-step plan for implementing a new feature and saves it to 'plan.txt'. Usage: /plan-feature <feature description>",
    "prompt_template": "You are tasked with planning the implementation of the following feature: {{args}}. Your goal is to produce a comprehensive, actionable plan, adhering to the 'Intern++' mandate's principles for thorough software development.\n\nYour plan, to be written to 'plan.txt', should be structured and detailed. Specifically, include these sections:\n1.  **Feature Understanding & Requirements Clarification:**\n    *   Restate the feature request in your own words to confirm understanding.\n    *   Identify any ambiguities or missing information. Note any assumptions you make to proceed with planning.\n    *   Break down the feature into clear, testable requirements.\n2.  **Analysis & Investigation Strategy (How you *would* investigate if executing the plan):**\n    *   Outline which files/modules you anticipate needing to examine (e.g., using `Read`, `LS`, `Tree`, `Glob`).\n    *   Describe how you would identify all existing code related to this feature or affected by it (e.g., using `Grep` for function calls, class names, relevant keywords across suspected directories like 'src', 'app', 'tests').\n    *   Include specific grep patterns you would use (e.g., function names, class references, API endpoints).\n3.  **Impact Assessment:**\n    *   List the files and modules likely to be modified.\n    *   Briefly describe the expected impact on other parts of the system (e.g., API changes, UI changes, database schema modifications, dependent services).\n    *   Assess potential backwards compatibility issues or migration considerations.\n    *   Consider performance implications, if any.\n4.  **Implementation Steps:**\n    *   Provide a detailed, step-by-step guide for the code changes. Be specific about new functions/classes/methods, modifications to existing ones, and data structures.\n    *   Mention considerations for adhering to existing project conventions and coding style (which would be inferred by `Read`ing related files).\n    *   Include pseudo-code for complex algorithms or logic where appropriate.\n    *   Organize implementation steps in logical phases (e.g., backend changes first, then frontend, then tests).\n5.  **Testing Strategy:**\n    *   Outline how existing tests (unit, integration, e2e) would need to be updated.\n    *   Specify what new tests would be necessary to validate the feature and cover key scenarios/edge cases.\n    *   Include test data requirements and mock objects needed.\n    *   Indicate the likely test commands to be used (e.g. `npm test`, `pytest`).\n    *   Suggest debug/verification strategies during implementation.\n6.  **Potential Challenges & Edge Cases:**\n    *   Identify any potential difficulties, risks, or edge cases to consider during implementation.\n    *   Suggest mitigation strategies for each identified risk.\n    *   Note any performance concerns or scalability considerations.\n7.  **Documentation Update Points:**\n    *   Note any documentation (inline comments, README, API docs, diagrams) that would need updating.\n    *   Suggest format and placement for new documentation.\n    *   Consider user-facing documentation needs (if applicable).\n8.  **Rollout Considerations:**\n    *   Discuss any deployment concerns (e.g., database migrations, feature flags).\n    *   Suggest a verification strategy post-deployment.\n    *   Consider whether a phased rollout would be appropriate.\n\n**Action Steps for You:**\n1.  Compose the detailed plan as described above. Format it clearly, using markdown with headings for each section.\n2.  Use the 'Write' tool to save this plan to 'plan.txt' in the project root.\n3.  After successfully writing the plan, inform the user that the plan is saved to 'plan.txt' and briefly summarize that it covers understanding, analysis, implementation, testing, and potential challenges for the feature '{{args}}'.\n\n**Constraint:** Do NOT execute any part of the implementation or testing plan yourself at this stage. Your sole output for this command is the plan document and the confirmation message.",
    "arg_placeholder": "{{args}}"
  },
  "analyse-project": {
    "description": "Performs an analysis of the current project structure, main files, and potential technologies. Usage: /analyse-project",
    "prompt_template": "The user has invoked the 'analyse-project' command. Your task is to provide a comprehensive analysis of the current project. Please perform the following steps diligently:\n1.  **Initial Overview & Structure:**\n    *   Use `LS` on the project root (`.`) to get a top-level view of files and directories.\n    *   Use the `Tree` tool (e.g., with `dirPath: '.'`, `maxDepth: 2` or `3`, and default ignores) to visualize the project structure. If the root is too large or `Tree` is too verbose, consider running `Tree` on suspected source or application directories identified from the `LS` output (e.g., 'src', 'app', 'lib').\n    *   Look for .git directories or configuration files to identify if this is a Git repository. If found, consider using `Bash` to run `git log --oneline --max-count=5` to get a brief history.\n2.  **Identify Key Components:**\n    *   Based on tool outputs and common project conventions, identify and list:\n        *   Potential main source directories (e.g., 'src', 'app', 'lib', 'components', 'pages', 'cmd', 'pkg', 'internal').\n        *   Test directories (e.g., 'tests', 'specs', '__tests__', 'e2e', 'test').\n        *   Key configuration files (e.g., 'package.json', 'pyproject.toml', 'poetry.lock', 'Pipfile', 'Gemfile', 'pom.xml', 'build.gradle', 'Makefile', 'justfile', 'vite.config.js', 'next.config.js', 'webpack.config.js', 'tsconfig.json', '.env.example', 'Dockerfile', 'docker-compose.yml', 'settings.py', 'config/application.rb').\n        *   CI/CD configuration files (e.g., '.github/workflows', '.gitlab-ci.yml', 'Jenkinsfile', '.travis.yml', '.circleci').\n        *   Static analysis and code quality tools (e.g., '.eslintrc', '.prettierrc', '.pylintrc', 'mypy.ini').\n3.  **Content Examination (Sampling for Insights):**\n    *   Use the `Read` tool to examine the content of a few (3-5) critical files to understand core aspects. Prioritize:\n        *   Project manifest/dependency files (e.g., `package.json`, `pyproject.toml`).\n        *   The main `README.md` (if it exists and seems informative).\n        *   Any identifiable main application entry point (e.g., 'src/main.js', 'src/index.js', 'app/app.py', 'cmd/main.go', 'manage.py', 'Program.cs').\n        *   A key build or task configuration file (e.g., `vite.config.js`, `Makefile`, `package.json` scripts section).\n        *   Database configuration files or ORM models if identifiable.\n    *   From these files, try to deduce dependencies, stated purpose, build/run/test scripts, and main modules/frameworks.\n4.  **Dependency Analysis:**\n    *   For JavaScript/TypeScript projects, check `package.json` for dependencies and devDependencies.\n    *   For Python projects, check `requirements.txt`, `pyproject.toml`, or `Pipfile` for dependencies.\n    *   For Java projects, examine `pom.xml` or `build.gradle` for dependencies.\n    *   Categorize dependencies as core frameworks, testing libraries, build tools, etc.\n5.  **Architecture Pattern Recognition:**\n    *   Based on the project structure and files examined, try to identify common architecture patterns:\n        *   MVC, MVVM, Clean Architecture, Microservices, etc.\n        *   Client-server, serverless, monolithic, etc.\n    *   Note any evidence of design patterns being used (e.g., factories, repositories, services).\n6.  **Synthesize and Summarize Findings:**\n    *   Compile your findings into a clear, structured summary for the user. Include:\n        a.  **Project Purpose/Type:** Your best assessment (e.g., web application, REST API, library, CLI tool, data processing pipeline). State any key assumptions made.\n        b.  **Main Technologies:** Programming language(s), primary frameworks/runtimes (e.g., Node.js, Spring Boot, Django, React), major libraries (mention versions if easily found in config files).\n        c.  **Architecture Overview:** The apparent architecture pattern and key design decisions.\n        d.  **Directory Structure Overview:** A brief explanation of the perceived role of key identified folders.\n        e.  **Key Scripts & Operations:** How the project appears to be built, run, and tested (e.g., specific commands from `package.json` scripts, `Makefile` targets, or common tool invocations like `mvn spring-boot:run`).\n        f.  **Data & State:** Any indications of database usage, migrations, or state management patterns.\n        g.  **CI/CD & Quality:** Overview of any CI/CD pipelines, linting, formatting, or testing automation.\n        h.  **Other Significant Observations:** Anything else noteworthy (e.g., use of Docker, specific build tools, linter configurations if obvious, CI/CD setup clues from files like `.github/workflows`).\n7.  **Development Environment Setup (Optional):**\n    *   If there are clear instructions or configuration for setting up a development environment (e.g., `.env.example`, `docker-compose.yml`), summarize what would be needed to get started with development.\n\n**Constraints:**\n*   Present this summary clearly and concisely. Use markdown for better formatting if appropriate.\n*   Do NOT make any file modifications during this analysis task. You are only observing and reporting.",
    "arg_placeholder": null
  },
  "run-tests": {
    "description": "Executes the project's test suite. Usage: /run-tests",
    "prompt_template": "The user wants to run the project's test suite. \n1. First, try to identify the common test script command for this project. Look for clues in 'package.json' (e.g., a 'test' script), or common commands for typical project types (e.g., 'pytest', 'go test ./...', 'mvn test', 'gradle test', 'rake test'). If multiple possibilities exist or it's unclear, you can list them and ask the user, or pick the most common one for the likely project type (identified via 'analyse-project' like logic if necessary).\n2. Once a command is identified (or if you have a strong educated guess), use the 'Bash' tool to execute it. Ensure 'background' is 'false'.\n3. Present the 'stdout' and 'stderr' from the test execution to the user. If tests fail, clearly indicate this.",
    "arg_placeholder": null
  },
  "generate-readme": {
    "description": "Generates a README.md file based on project analysis. Usage: /generate-readme",
    "prompt_template": "The user wants to generate a README.md for the project.\n1.  **Project Analysis for README Content:**\n    *   Perform a concise analysis of the project to gather information for the README. Use tools like:\n        *   `LS` (root directory and key subdirectories like 'src', 'app').\n        *   `Tree` (shallow depth, e.g., `maxDepth: 2`, on root or key subdirectories).\n        *   `Read` on key files such as `package.json`, `pyproject.toml`, `pom.xml`, `Gemfile`, `Makefile`, `justfile`, any existing (but perhaps minimal or outdated) `README.md`, and 1-2 main source files (e.g., `src/index.js`, `app/main.py`, `cmd/main.go`) to understand its purpose, main language/framework, dependencies, and how it might be built, run, and tested.\n        *   `Glob` to find common configuration or source file patterns if needed to infer technology stack or project type (e.g., `Glob` for `*config.js`, `src/**/*.py`, `*.csproj`).\n        *   Check for any screenshots, images, or diagrams in the project that could be referenced in the README.\n2.  **Look for Project Specifics:**\n    *   Search for API documentation, OpenAPI/Swagger files, or API endpoints in the code.\n    *   Look for environment variables used in the project (e.g., in `.env.example` or configuration files).\n    *   Check for license information in existing files.\n    *   Identify any command-line arguments or configuration options the project uses.\n3.  **Compose README.md Draft:**\n    *   Based on your analysis, compose a draft for a `README.md` file using Markdown. It should include at least the following sections. If specific information isn't readily available from your analysis, use clear placeholders like `[TODO: Add details on X]` or suggest what the user should fill in.\n        *   `# Project Title` (Infer a suitable title, e.g., from the project directory name or a `name` field in `package.json`/`pyproject.toml`).\n        *   `## Overview / Description` (A brief summary of what the project does, its primary purpose, and key functionalities. Aim for 2-3 sentences).\n        *   `## Features` (List 3-5 key features if apparent from your analysis, e.g., \"- User authentication\", \"- Real-time data processing\").\n        *   `## Tech Stack / Technologies Used` (List main programming languages, frameworks, key libraries, databases, runtime environments. E.g., \"- Language: Python 3.9\", \"- Framework: Django 4.0\", \"- Database: PostgreSQL\").\n        *   `## Prerequisites` (Any software, tools, or accounts needed *before* setup, e.g., \"- Node.js v18+\", \"- Python v3.8+\", \"- Docker Desktop\", \"- AWS Account\").\n        *   `## Getting Started / Setup & Installation` (Clear, numbered steps to get the development environment running. E.g., '1. Clone the repository: `git clone https://github.com/user/project.git`', '2. Navigate to the project directory: `cd project-name`', '3. Install dependencies: `npm install` / `pip install -r requirements.txt` / `bundle install` / `mvn install`'). Refer to specific commands found in `package.json` scripts, `Makefile`, etc. if available.\n        *   `## Environment Variables` (If applicable, list environment variables and what they're used for, e.g., '- `DATABASE_URL`: Connection string for the database. Default: `postgres://localhost:5432/app`').\n        *   `## Running the Project / Usage` (How to run the application or main executable for development or basic use. E.g., 'Run `npm run dev` for development server' or 'Execute `python app/main.py --input data.csv`').\n        *   `## API Documentation` (If applicable, include basic API usage, endpoints, or link to more comprehensive docs).\n        *   `## Running Tests` (How to execute the test suite. E.g., 'Run tests with `npm test` / `pytest` / `mvn test`').\n        *   `## Project Structure` (A brief explanation of key directories, e.g., \"- `src/`: Main source code\", \"- `tests/`: Unit and integration tests\", \"- `docs/`: Project documentation\"). You could use a very shallow `Tree` output here if concise.\n        *   `## Deployment` (If applicable, brief notes on how to deploy the project to production).\n        *   `## Contributing` (Placeholder: \"Contributions are welcome! Please read `CONTRIBUTING.md` (if it exists) or follow standard fork & pull request workflow. [Suggest creating a CONTRIBUTING.md with guidelines if one doesn't exist]\").\n        *   `## License` (Placeholder: \"This project is licensed under the [LICENSE_NAME] License. See the `LICENSE` file for details.\" If no license file, state: \"[TODO: Add license information. Consider choosing an open-source license like MIT or Apache 2.0 and adding a LICENSE file.]\").\n        *   `## Acknowledgments` (Optional: credit any third-party resources, inspirations, or contributors).\n4.  **Write README.md (with Overwrite Check):**\n    *   **Crucial Step:** Before writing, use `LS .` (or `Glob README.md`) to check if a `README.md` file already exists in the project root.\n    *   If `README.md` **exists**: Ask the user: \"A `README.md` file already exists. Do you want me to overwrite it with the newly generated content? (yes/no)\". \n        *   If the user responds 'yes' (or similar affirmative like 'y', 'ok', 'proceed'), then proceed to use the `Write` tool to save your composed content to `README.md`.\n        *   If the user responds 'no' (or similar negative like 'n', 'cancel', 'stop'), DO NOT write the file. Inform the user: \"Okay, I have not overwritten the existing `README.md`. The generated content is available in our current conversation if you'd like to copy it.\"\n    *   If `README.md` **does not exist**: Proceed directly to use the `Write` tool to save your composed content to `README.md`.\n5.  **Inform User:**\n    *   If the README was written, inform the user: \"I have generated and saved `README.md` in the project root.\"\n    *   If the README was not written due to user declining overwrite, ensure your message reflects that, as guided above.\n    *   Suggest any other documentation that might be valuable to create (e.g., CONTRIBUTING.md, CHANGELOG.md).\n\nMake sure the generated README content is well-formatted, professional, and genuinely helpful based on your analysis. Use badges where appropriate (e.g., build status, license, version) if you can determine the relevant information from the project.",
    "arg_placeholder": null
  },
  "find-todos": {
    "description": "Searches the codebase for TODO, FIXME, and XXX comments and summarizes them. Usage: /find-todos [directory]",
    "prompt_template": "The user wants to find all TODO, FIXME, and similar comments in the project within the specific directory or pattern: {{args}}{{/if}}.\n1.  **Identify Target Files:**\n    *   Use the `Glob` tool to find relevant source code files. {{#if args}}Focus on the user-specified directory or pattern: {{args}}{{else}}Aim for broad but sensible patterns covering common source code extensions. Examples:\n        *   `src/**/*.{js,ts,jsx,tsx,py,rb,java,go,cs,php,html,css,scss,less,vue,svelte,swift,kt,rs}`\n        *   `app/**/*.{js,ts,jsx,tsx,py,rb,java,go,cs,php,html,css,scss,less,vue,svelte,swift,kt,rs}`\n        *   `lib/**/*.{js,ts,jsx,tsx,py,rb,java,go,cs,php,html,css,scss,less,vue,svelte,swift,kt,rs}`\n        *   `tests/**/*.{js,ts,jsx,tsx,py,rb,java,go,cs,php,vue,svelte,swift,kt,rs}` (also check test files)\n        *   `*.{py,js,ts,rb,go,php}` (in root, if applicable for scripts or simple projects){{/if}}\n    *   The `Glob` tool's default ignore patterns (like `node_modules/**`, `dist/**`, `.git/**`) will automatically apply. Ensure your pattern doesn't inadvertently include build artifacts or vendor directories if not covered by default ignores.\n    *   If `Glob` returns a very large number of files (e.g., over 50-100), list the count and a few example patterns that matched. Then, ask the user: \"I found [number] files matching these patterns. Searching all of them might take a while. Do you want to proceed with all, or would you like to provide more specific `Glob` patterns (e.g., focusing on a specific directory like `src/core/**/*.js`)?\"\n2.  **Search for Comments (Efficiently):**\n    *   If proceeding with the file list (either full or user-refined):\n    *   For each identified file, you need to search for lines containing `TODO`, `FIXME`, or `XXX`. The regex should be case-insensitive. The target regex pattern is `(TODO|FIXME|XXX)` with flags `i`.\n    *   **Efficient Execution using Batch:** To process multiple files, prepare a list of `Grep` tool calls, one for each file. Then, use the `Batch` tool to execute all these `Grep` calls in parallel. Example of a `Batch` call parameter if `Glob` returned `file1.js` and `file2.py`:\n      `<tool_call>{\"name\": \"Batch\", \"parameters\": {\"calls\": [{\"name\": \"Grep\", \"parameters\": {\"filePath\": \"src/file1.js\", \"regex\": \"(TODO|FIXME|XXX)\", \"flags\": \"i\"}}, {\"name\": \"Grep\", \"parameters\": {\"filePath\": \"app/file2.py\", \"regex\": \"(TODO|FIXME|XXX)\", \"flags\": \"i\"}}]}}</tool_call>`\n      (Adapt file paths based on Glob output).\n3.  **Compile and Present Results:**\n    *   After the `Batch` tool (containing `Grep` calls) completes, process the `tool_responses` array it returns.\n    *   Compile a list of all findings. For each finding from a successful `Grep` sub-call (where `Grep` found matches), include:\n        *   File path (relative to project root)\n        *   Line number\n        *   The full content of the line containing the comment.\n    *   Group the findings by type (TODO, FIXME, XXX) and by file for better organization.\n    *   For each TODO/FIXME/XXX, try to extract the actual task description from the comment for clarity.\n    *   Present this summary to the user. If there are many findings, group them by file path for readability.\n    *   Include a count summary at the top (e.g., \"Found 15 TODOs, 3 FIXMEs, and 1 XXX across 8 files\").\n    *   If no TODOs, FIXMEs, or XXXs are found in any of the checked files, state that clearly: \"I searched the specified files and found no TODO, FIXME, or XXX comments.\"\n    *   If some `Grep` calls within the `Batch` failed (e.g., file deleted between `Glob` and `Grep`, or a permissions issue), note these errors in a separate section of your response (e.g., \"Note: Could not process `some/file.js` due to error: [error message from tool_response]\").\n4.  **Offer to Export Results (Optional):**\n    *   Ask the user if they would like you to export the findings to a file (e.g., \"todos.md\").\n    *   If they agree, format the findings in a clear, structured markdown document with appropriate headings and lists, and use the `Write` tool to save it.",
    "arg_placeholder": null
  },
  "explain-file": {
    "description": "Reads a file and provides an explanation of its purpose and functionality. Usage: /explain-file <filePath>",
    "prompt_template": "The user wants an explanation of the file: '{{args}}'.\n\n1.  **Read File Content:**\n    *   Use the 'Read' tool to get the full content of '{{args}}'.\n    *   If the 'Read' tool fails (e.g., file not found at '{{args}}' or access denied), report this specific error to the user and stop.\n2.  **Analyze Content and Summarize:**\n    *   After successfully reading the file, analyze its content thoroughly.\n    *   Provide a concise yet comprehensive summary. Structure your explanation with the following points, using markdown for clarity:\n        *   **File Path & Language:** State the full relative file path (`{{args}}`) and the programming language (e.g., JavaScript, Python, Java), typically inferred from its extension.\n        *   **Primary Purpose:** In 1-2 sentences, what is the main role or responsibility of this file within the project? (e.g., 'Defines the User model and related database interaction logic for the accounts module.', 'Contains utility functions for date and time manipulation, used across various services.', 'Serves as the main entry point and router configuration for the web application.').\n        *   **Key Components & Functionality:**\n            *   Identify and describe the major functions, classes, methods, variables, constants, or components defined within the file.\n            *   For each significant component, briefly explain its specific role and functionality.\n            *   If the file defines UI components (e.g., React, Vue, Svelte), describe what they render and their key props or state management aspects.\n            *   If it's a configuration file, explain the key settings and their purpose.\n        *   **Dependencies & Imports:** List notable modules, libraries, or other project files imported/required by this file. What external functionalities or internal modules does it rely on?\n        *   **Exports / Public API (if applicable):** What does this file make available to other parts of the system? (e.g., exported functions like `formatDate`, classes like `UserService`, constants like `API_ENDPOINT`).\n        *   **Usage Examples (if discernible):** If you can infer how this file's exports might be used, provide a brief code example.\n        *   **Potential Interactions & Usage Context:** Based on its exports, imports, and common software design patterns, how might this file be used by or interact with other parts of the project? (e.g., 'This `UserService` class is likely instantiated and used by API controllers handling user-related requests.', 'These utility functions in `stringUtils.js` are probably imported by various modules needing string operations.'). Avoid excessive speculation if no clear evidence.\n        *   **Overall Structure (if complex or noteworthy):** For larger or non-trivial files, briefly comment on its internal organization (e.g., 'The file is organized into sections for route definitions, middleware, and error handlers.', 'It follows a typical class structure with private helper methods and public API methods.').\n        *   **Code Quality Observations (optional):** If there are notable positive aspects (e.g., good documentation, consistent patterns) or potential improvement opportunities (e.g., complex functions, limited error handling), briefly mention them.\n3.  **Explore Related Files (Optional but Highly Valuable):**\n    *   Use `Grep` to find other files that import or use this file (if it exports functionality).\n    *   Use `Grep` to find places where defined functions or classes are used elsewhere in the codebase.\n    *   If valuable context is found, include a brief \"Related Files\" section mentioning how this file integrates with others.\n4.  **Present Explanation:**\n    *   Present this explanation clearly to the user. Use bullet points or subheadings for readability, especially if the explanation is detailed.\n    *   If the file is very simple (e.g., a short configuration JSON with few keys, or a file with a single trivial function), keep the explanation appropriately brief and to the point, focusing on its direct purpose.",
    "arg_placeholder": "{{filePath}}"
  },
  "help": {
    "description": "Displays available commands and their descriptions.",
    "type": "client_side_handler"
  },
  "develop": {
    "description": "Generate a plan and execute it step-by-step for the given task.",
    "prompt_template": "Generate a plan for the task: '{{arg}}'. Use tools to explore the project structure and read necessary files for planning. Output the plan as an array of actionable string steps within <plan>[...]</plan> tags. Example: <plan>[\"Create auth/ directory\", \"Write JWT utils in auth/jwt_utils.py\"]</plan>.",
    "arg_placeholder": "{{arg}}"
  }
}
