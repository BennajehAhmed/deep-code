{
  "plan-feature": {
    "description": "Creates a detailed step-by-step plan for implementing a new feature and saves it to 'plan.txt'. Usage: /plan-feature <feature description>",
    "prompt_template": "You were tasked with planning the implementation of the following feature: {{args}}. Your task is to: 1. Create a detailed step-by-step plan for implementing this feature. Consider aspects like understanding requirements, identifying affected files, outlining code changes, thinking about necessary tests, and any potential challenges. 2. Write this detailed plan to a file named 'plan.txt' in the project root using the 'Write' tool. 3. After successfully writing the plan, inform the user that the plan is saved and where they can find it. Do not proceed with executing any steps of the plan yourself at this stage.",
    "arg_placeholder": "{{args}}"
  },
  "analyse-project": {
    "description": "Performs an analysis of the current project structure, main files, and potential technologies. Usage: /analyse-project",
    "prompt_template": "The user has invoked the 'analyse-project' command. Your task is to provide a comprehensive analysis of the current project. Please perform the following steps:\n1. Use the `Tree` tool (e.g., with depth 3, and default ignores) to get an overview of the project structure. Also consider using `LS` for the root directory if `Tree` is too verbose initially.\n2. Based on the tool outputs and common project conventions, identify potential main source directories (e.g., 'src', 'app', 'lib', 'components', 'pages'), test directories (e.g., 'tests', 'specs', '__tests__'), and key configuration files (e.g., 'package.json', 'pyproject.toml', 'Gemfile', 'pom.xml', 'vite.config.js', 'next.config.js', 'webpack.config.js', 'tsconfig.json', '.env.example', 'Dockerfile', 'docker-compose.yml').\n3. Use the `Read` tool to examine the content of a few (2-3) key identified files (like 'package.json', 'README.md', and any main application entry point if easily identifiable e.g., 'src/main.js', 'src/index.js', 'app/app.py', 'cmd/main.go') to understand dependencies, stated purpose, and potential entry points.\n4. Synthesize this information and summarize your findings for the user. Your summary should include:\n    a. The likely purpose or type of the project (e.g., web application, library, CLI tool, data processing pipeline).\n    b. The main programming language(s) and any obvious frameworks or major libraries used (mention versions if easily found in config files).\n    c. A brief overview of the directory structure and the perceived role of key folders.\n    d. Any other significant observations, such as build scripts, test commands, or how the project might be run.\nPresent this summary clearly and concisely. Do not make any file modifications during this analysis task. You are only observing and reporting.",
    "arg_placeholder": null
  },
  "run-tests": {
    "description": "Executes the project's test suite. Usage: /run-tests",
    "prompt_template": "The user wants to run the project's test suite. \n1. First, try to identify the common test script command for this project. Look for clues in 'package.json' (e.g., a 'test' script), or common commands for typical project types (e.g., 'pytest', 'go test ./...', 'mvn test', 'gradle test', 'rake test'). If multiple possibilities exist or it's unclear, you can list them and ask the user, or pick the most common one for the likely project type (identified via 'analyse-project' like logic if necessary).\n2. Once a command is identified (or if you have a strong educated guess), use the 'Bash' tool to execute it. Ensure 'background' is 'false'.\n3. Present the 'stdout' and 'stderr' from the test execution to the user. If tests fail, clearly indicate this.",
    "arg_placeholder": null
  },
  "generate-readme": {
    "description": "Generates a README.md file based on project analysis. Usage: /generate-readme",
    "prompt_template": "The user wants to generate a README.md for the project.\n1. Perform a brief analysis of the project. You can use `LS`, `Tree` (shallow depth, e.g., 2), and `Read` on key files like `package.json`, `pyproject.toml`, or any existing main source files to understand its purpose, main language/framework, and how it might be run or built.\n2. Based on this analysis, compose a draft for a `README.md` file. It should include at least the following sections: \n    - `# Project Title` (Infer a suitable title or use the project directory name)\n    - `## Description` (A brief overview of what the project does or aims to do)\n    - `## Technologies Used` (List main languages, frameworks, key libraries)\n    - `## Setup/Installation` (Provide generic instructions or placeholders if specific steps aren't obvious, e.g., 'Clone the repository', 'Install dependencies using `npm install` / `pip install -r requirements.txt`')\n    - `## Usage` (How to run the project, e.g., 'Run `npm start`' or 'Execute `python main.py`')\n    - `## Running Tests` (If you identified a test command in step 1, mention it here, e.g., 'Run tests with `npm test`')\n3. Use the 'Write' tool to save this content to a file named 'README.md' in the project root. If a README.md already exists, ask the user if they want to overwrite it before proceeding with the 'Write' tool. If they decline, inform them that the README was not written.\n4. Inform the user that the README.md has been generated (or not, if they declined overwrite).",
    "arg_placeholder": null
  },
  "find-todos": {
    "description": "Searches the codebase for TODO and FIXME comments and summarizes them. Usage: /find-todos",
    "prompt_template": "The user wants to find all TODO and FIXME comments in the project.\n1. Use the `Glob` tool to find relevant source code files. Common patterns include `src/**/*.js`, `src/**/*.ts`, `app/**/*.py`, `lib/**/*.rb`, `*.java` etc. Try to infer good patterns based on project structure if possible, or use a broad set. Exclude `node_modules`, `dist`, `build` and similar directories (Glob's default ignores should help).\n2. For each file found by `Glob` (or a reasonable batch of them if there are many), use the `Grep` tool to search for lines containing `TODO` or `FIXME`. The regex should be case-insensitive, like `(TODO|FIXME)` with flag `i`.\n3. Compile a list of all findings. For each finding, include the file path, line number, and the content of the line.\n4. Present this summary to the user. If no TODOs or FIXMEs are found, state that.",
    "arg_placeholder": null
  },
  "explain-file": {
    "description": "Reads a file and provides an explanation of its purpose and functionality. Usage: /explain-file <filePath>",
    "prompt_template": "The user wants an explanation of the file '{{filePath}}'. \n1. Use the 'Read' tool to get the content of this file.\n2. After reading the file, analyze its content. \n3. Provide a concise summary that includes:\n    a. The primary purpose of the file.\n    b. Key functions, classes, or components defined within it and their roles.\n    c. How this file might interact with other parts of the project (if inferable).\n    d. Any notable dependencies it imports or uses.\nPresent this explanation clearly to the user.",
    "arg_placeholder": "{{filePath}}"
  },
  "help": {
    "description": "Displays available commands and their descriptions.",
    "type": "client_side_handler"
  }
}
